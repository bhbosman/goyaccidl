package gowriter

import (
	"fmt"
	log2 "github.com/bhbosman/gocommon/log"
	ctx2 "github.com/bhbosman/goyaccidl/ctx"
	"github.com/bhbosman/goyaccidl/objects"
	"io"
	"log"
	"reflect"
	"sort"
	"strings"
)

type FileGenerationContext struct {
	TargetFile           string
	appCtx               *ctx2.GoYaccAppCtx
	writer               io.Writer
	knownTypes           objects.KnownTypes
	subSystemLogger      *log2.SubSystemLogger
	StructWriter         *WriteStructDcl
	StructSkeletonWriter *WriteStructSkeletonDcl
	StructStubWriter     *WriteStructStubDcl
	UnionWriter          *WriteUnionDcl
	InterfaceWriter      *WriteInterface
	TypeDefDclWriter     *WriteTypeDefDcl
	ConstantValueWriter  *WriteConstantValue
	EnumDclWriter        *WriteEnumDcl
	ScopeDclWriter       *WriteScopeDcl
	NativeDclWriter      *WriteNativeDcl
	WritePrimitiveDcl    *WritePrimitiveDcl
	fileResolve          *ctx2.ResolveFileName
	WriteSeqStructDcl    *WriteStructSequenceDcl
}

func (w FileGenerationContext) WritePackageName(name string) error {
	_, _ = fmt.Fprintf(w.writer, "// Code generated by me. DO NOT EDIT.\n\n")
	_, _ = fmt.Fprintf(w.writer, "package %v\n", name)
	_, _ = fmt.Fprintf(w.writer, "\n")

	return nil
}

func (w FileGenerationContext) WriteImport(k string, v string, fileUsage objects.FileUsage) {
	_, _ = fmt.Fprintf(w.writer, "import %v \"%v\"\n", k, v)
	//_, _ = fmt.Fprintf(w.writer, "\t//import %v \"%v\"\n", k, v)
	//if data, ok := fileUsage[k]; ok {
	//	for _, d := range data.What {
	//		_, _ = fmt.Fprintf(w.writer, "\t// for %v\n", d)
	//	}
	//}
}

func (w FileGenerationContext) FoldersInUse(fileUsage *objects.FileData, folderName string) error {
	foldersInUseById := make(map[string]string)
	foldersInUseById[fileUsage.DestinationFolderId], _ = w.fileResolve.Resolve(folderName)

	ffff := func(use objects.FileUsage, foldersInUseById map[string]string) {
		for k, v := range use {
			if _, ok := foldersInUseById[k]; !ok {
				index := strings.Index(v.FolderName, w.appCtx.GoSrcPath)
				if index == 0 {
					foldersInUseById[k] = v.FolderName[len(w.appCtx.GoSrcPath)+1:]
					continue
				}
				foldersInUseById[k] = v.FolderName
			}
		}
	}
	ffff(fileUsage.FolderUsage, foldersInUseById)

	delete(foldersInUseById, fileUsage.DestinationFolderId)

	var keys []string
	for k := range foldersInUseById {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	for _, k := range keys {
		if v, ok := foldersInUseById[k]; ok {
			w.WriteImport(k, v, fileUsage.FolderUsage)
		}
	}
	if len(keys) > 0 {
		_, _ = fmt.Fprintf(w.writer, "\n")
	}
	return nil
}

func (w *FileGenerationContext) WriteMembers(
	knownTypes objects.KnownTypes,
	members objects.IDclArray) error {
	for _, member := range members {
		switch v := member.(type) {
		case *objects.PrimitiveDcl:
			err := w.WritePrimitiveDcl.Write(w, v, knownTypes)
			if err != nil {
				return err
			}
			break

		case *objects.SeqStructDcl:
			err := w.WriteSeqStructDcl.Write(w, v, knownTypes)
			if err != nil {
				return err
			}
			break

		case *objects.StructDcl:
			switch v.StructType {
			case objects.StructTypeAsDefined, objects.StructTypeAsMethodParamIn, objects.StructTypeAsMethodParamOut:
				err := w.StructWriter.Write(w, v, knownTypes)
				if err != nil {
					return err
				}
				break
			case objects.StructTypeAsIdlStub:
				err := w.StructStubWriter.Write(w, v, knownTypes)
				if err != nil {
					return err
				}
				break
			case objects.StructTypeAsIdlSkeleton:
				err := w.StructSkeletonWriter.Write(w, v, knownTypes)
				if err != nil {
					return err
				}
				break
			}
		case *objects.UnionDcl:
			err := w.UnionWriter.Write(w, v, knownTypes)
			if err != nil {
				return err
			}
			break
		case *objects.InterfaceDcl:
			err := w.InterfaceWriter.Write(w, v, knownTypes)
			if err != nil {
				return err
			}
			break
		case *objects.TypeDefDcl:
			err := w.TypeDefDclWriter.Write(w, v, knownTypes)
			if err != nil {
				return err
			}
			break
		case *objects.ConstantValue:
			err := w.ConstantValueWriter.Write(w, v, knownTypes)
			if err != nil {
				return err
			}
			break
		case *objects.EnumDcl:
			err := w.EnumDclWriter.Write(w, v, knownTypes)
			if err != nil {
				return err
			}
			break
		case *objects.ScopeDcl:
			err := w.ScopeDclWriter.Write(w, v, knownTypes)
			if err != nil {
				return err
			}
			break
		//case *objects.SequenceTypeDcl:
		//	err := w.SequenceTypeDclWriter.Write(w, v, knownTypes)
		//	if err != nil {
		//		return err
		//	}
		//	break
		case *objects.NativeDcl:
			err := w.NativeDclWriter.Write(w, v, knownTypes)
			if err != nil {
				return err
			}
		default:
			s := fmt.Sprintf("No handler found for %v(%v). LexemData: %v", reflect.TypeOf(member).String(), member.GetName(), member.GetLexemData())
			w.subSystemLogger.LogWithLevel(0, func(logger *log.Logger) { logger.Print(s) })
		}
	}
	return nil
}

func (w FileGenerationContext) WriteGlobalVariables(types objects.KnownTypes, members objects.IDclArray) error {
	for _, member := range members {
		switch v := member.(type) {
		case *objects.PrimitiveDcl:
			err := w.WritePrimitiveDcl.WriteGlobalVariables(w, v)
			if err != nil {
				return nil
			}
			break
		case *objects.StructDcl:
			switch v.StructType {
			case objects.StructTypeAsDefined, objects.StructTypeAsMethodParamIn, objects.StructTypeAsMethodParamOut:
				err := w.StructWriter.WriteGlobalVariables(w, v)
				if err != nil {
					return nil
				}
				break
			}
		case *objects.SeqStructDcl:
			err := w.WriteSeqStructDcl.WriteGlobalVariables(w, v)
			if err != nil {
				return nil
			}
			break

		case *objects.UnionDcl:
			err := w.UnionWriter.WriteGlobalVariables(w, v)
			if err != nil {
				return nil
			}
			break
		case *objects.InterfaceDcl:
			err := w.InterfaceWriter.WriteGlobalVariables(w, v)
			if err != nil {
				return nil
			}
			break
		case *objects.TypeDefDcl:
			err := w.TypeDefDclWriter.WriteGlobalVariables(w, v, types)
			if err != nil {
				return nil
			}
			break
		case *objects.ConstantValue:
			err := w.ConstantValueWriter.WriteGlobalVariables(w, v)
			if err != nil {
				return nil
			}
			break
		case *objects.EnumDcl:
			err := w.EnumDclWriter.WriteGlobalVariables(w, v)
			if err != nil {
				return nil
			}
			break
		case *objects.ScopeDcl:
			err := w.ScopeDclWriter.WriteGlobalVariables(w, v)
			if err != nil {
				return nil
			}
			break
		//case *objects.SequenceTypeDcl:
		//	err := w.SequenceTypeDclWriter.WriteGlobalVariables(w, v)
		//	if err != nil {
		//		return nil
		//	}
		//	break
		case *objects.NativeDcl:
			err := w.NativeDclWriter.WriteGlobalVariables(w, v)
			if err != nil {
				return nil
			}
		default:
			s := fmt.Sprintf("No handler found for %v(%v). LexemData: %v", reflect.TypeOf(member).String(), member.GetName(), member.GetLexemData())
			w.subSystemLogger.LogWithLevel(0, func(logger *log.Logger) { logger.Print(s) })
		}
	}
	return nil
}

func (w *FileGenerationContext) WritePackageInit(types objects.KnownTypes, members objects.IDclArray, knownTypes objects.KnownTypes) error {
	_, _ = fmt.Fprintf(w.writer, "\n")
	_, _ = fmt.Fprintf(w.writer, "func init() {\n")
	for _, member := range members {
		switch v := member.(type) {
		case *objects.PrimitiveDcl:
			err := w.WritePrimitiveDcl.WritePackageInit(w, v)
			if err != nil {
				return err
			}
		case *objects.SeqStructDcl:
			err := w.WriteSeqStructDcl.WritePackageInit(w, v)
			if err != nil {
				return err
			}
		case *objects.StructDcl:
			switch v.StructType {
			case objects.StructTypeAsDefined, objects.StructTypeAsMethodParamIn, objects.StructTypeAsMethodParamOut:
				err := w.StructWriter.WritePackageInit(w, v)
				if err != nil {
					return err
				}
			}
		case *objects.UnionDcl:
			err := w.UnionWriter.WritePackageInit(w, v)
			if err != nil {
				return err
			}
		case *objects.InterfaceDcl:
			err := w.InterfaceWriter.WritePackageInit(w, v)
			if err != nil {
				return err
			}
		case *objects.TypeDefDcl:
			err := w.TypeDefDclWriter.WritePackageInit(w, v, knownTypes)
			if err != nil {
				return err
			}
		case *objects.ConstantValue:
			err := w.ConstantValueWriter.WritePackageInit(w, v)
			if err != nil {
				return err
			}
		case *objects.EnumDcl:
			err := w.EnumDclWriter.WritePackageInit(w, v)
			if err != nil {
				return err
			}
		case *objects.ScopeDcl:
			err := w.ScopeDclWriter.WritePackageInit(w, v)
			if err != nil {
				return err
			}
		//case *objects.SequenceTypeDcl:
		//	err := w.SequenceTypeDclWriter.WritePackageInit(w, v)
		//	if err != nil {
		//		return err
		//	}
		case *objects.NativeDcl:
			err := w.NativeDclWriter.WritePackageInit(w, v)
			if err != nil {
				return err
			}
		default:
			s := fmt.Sprintf("No handler found for %v(%v). LexemData: %v", reflect.TypeOf(member).String(), member.GetName(), member.GetLexemData())
			w.subSystemLogger.LogWithLevel(0, func(logger *log.Logger) { logger.Print(s) })
		}
	}
	_, _ = fmt.Fprintf(w.writer, "}\n")

	return nil
}

func NewFileGenerationContext(
	targetFile string,
	appCtx *ctx2.GoYaccAppCtx,
	knownTypes map[objects.ScopeIdentifier]objects.IDcl,
	logFactory *log2.LogFactory,
	writer io.Writer,
	StructWriter *WriteStructDcl,
	UnionWriter *WriteUnionDcl,
	InterfaceWriter *WriteInterface,
	TypeDefDclWriter *WriteTypeDefDcl,
	ConstantValueWriter *WriteConstantValue,
	EnumDclWriter *WriteEnumDcl,
	ScopeDclWriter *WriteScopeDcl,
	NativeDclWriter *WriteNativeDcl,
	WritePrimitiveDcl *WritePrimitiveDcl,
	WriteSeqStructDcl *WriteStructSequenceDcl,
	fileResolve *ctx2.ResolveFileName,
	StructSkeletonWriter *WriteStructSkeletonDcl,
	StructStubWriter *WriteStructStubDcl) FileGenerationContext {
	logger := logFactory.Create("GoWriter")
	return FileGenerationContext{
		TargetFile:           targetFile,
		appCtx:               appCtx,
		writer:               writer,
		knownTypes:           knownTypes,
		subSystemLogger:      logger,
		StructWriter:         StructWriter,
		StructSkeletonWriter: StructSkeletonWriter,
		StructStubWriter:     StructStubWriter,
		UnionWriter:          UnionWriter,
		InterfaceWriter:      InterfaceWriter,
		TypeDefDclWriter:     TypeDefDclWriter,
		ConstantValueWriter:  ConstantValueWriter,
		EnumDclWriter:        EnumDclWriter,
		ScopeDclWriter:       ScopeDclWriter,
		NativeDclWriter:      NativeDclWriter,
		WritePrimitiveDcl:    WritePrimitiveDcl,
		fileResolve:          fileResolve,
		WriteSeqStructDcl:    WriteSeqStructDcl,
	}
}
